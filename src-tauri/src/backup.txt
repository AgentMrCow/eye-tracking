use base64::{engine::general_purpose, Engine as _};
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{OptionalExtension, Result as SqlResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::sync::Arc;
use tauri::{AppHandle, Manager, State};
use tauri::path::BaseDirectory;

/* ──────────────────────────────────────────────────────────────
   Data types
   ────────────────────────────────────────────────────────────── */

#[derive(Debug, Serialize, Deserialize)]
pub struct WordWindow {
    chinese_word: String,
    start_sec: f64,
    end_sec: f64,
    test_name: String,
    timeline: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GazeData {
    gaze_x: Option<f64>,
    gaze_y: Option<f64>,
    box_name: String,
    media_name: String,
    timeline: String,
    participant: String,
    recording: String,
    timestamp: String,
    test_name: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GazeStats {
    box_percentages: HashMap<String, f64>,
    total_points: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AoiRow {
    tag: String,
    region_id: String,
    rgb_hex: Option<String>,
}

/* Minimal “meta” used by the UI filters/badges */
#[derive(Debug, Serialize, Deserialize)]
pub struct TestMetaRow {
    test_name: String,
    sentence: Option<String>,
    truth_value: Option<String>,
    only_position: Option<String>,
    morpheme: Option<String>,
    series: Option<String>,
    case_no: Option<i64>, // parsed from TEXT if present
}

/* Full(er) catalog row for the new endpoint */
#[derive(Debug, Serialize, Deserialize)]
pub struct TestCatalogRow {
    test_name: String,
    sentence: Option<String>,
    group: Option<String>,
    correct_AOIs: Option<String>,
    potentially_correct_AOIs: Option<String>,
    incorrect_AOIs: Option<String>,
    correct_NULL: Option<String>,
    potentially_correct_NULL: Option<String>,
    incorrect_NULL: Option<String>,
    truth_value: Option<String>,
    only_position: Option<String>,
    morpheme: Option<String>,
    series: Option<String>,
    case_no: Option<i64>,        // parsed from TEXT
    image_name: Option<String>,  // "Image name"
    timeline: Option<String>,
    word_windows_json: Option<String>,
    missing: Option<String>,
    image_path: Option<String>,
}

/* recordings table */
#[derive(Debug, Serialize, Deserialize)]
pub struct RecordingRow {
    recording: String,
    participant: String,
    timeline: String,
    duration: Option<String>,
    date: Option<String>,
    gaze_samples: Option<i64>,
}

pub struct DbPool(Arc<Pool<SqliteConnectionManager>>);

/* ──────────────────────────────────────────────────────────────
   Helpers
   ────────────────────────────────────────────────────────────── */

fn table_exists(conn: &rusqlite::Connection, name: &str) -> bool {
    let mut stmt = match conn.prepare(
        "SELECT 1 FROM sqlite_master WHERE type='table' AND name=?1 LIMIT 1",
    ) {
        Ok(s) => s,
        Err(_) => return false,
    };
    stmt.exists([name]).unwrap_or(false)
}

/* ──────────────────────────────────────────────────────────────
   Gaze-data backed commands
   ────────────────────────────────────────────────────────────── */

#[tauri::command]
async fn get_participants(pool: State<'_, DbPool>) -> Result<Vec<String>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    let mut stmt = conn
        .prepare(r#"SELECT DISTINCT "Participant name" FROM gaze_data ORDER BY "Participant name""#)
        .map_err(|e| e.to_string())?;

    let participants = stmt
        .query_map([], |row| row.get(0))
        .map_err(|e| e.to_string())?
        .collect::<SqlResult<Vec<String>>>()
        .map_err(|e| e.to_string())?;

    Ok(participants)
}

#[tauri::command]
async fn get_test_names(pool: State<'_, DbPool>) -> Result<Vec<String>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    let mut stmt = conn
        .prepare(r#"SELECT DISTINCT "Test Name" FROM gaze_data ORDER BY "Test Name""#)
        .map_err(|e| e.to_string())?;

    let names = stmt
        .query_map([], |row| row.get::<_, String>(0))
        .map_err(|e| e.to_string())?
        .collect::<SqlResult<Vec<String>>>()
        .map_err(|e| e.to_string())?;

    Ok(names)
}

#[tauri::command]
async fn get_gaze_data(
    test_name: String,
    participants: Vec<String>,
    pool: State<'_, DbPool>,
) -> Result<Vec<GazeData>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;

    let mut query = String::from(
        r#"SELECT "Gaze point X", "Gaze point Y", Box, "Presented Media name",
                  "Timeline name", "Participant name", "Recording name",
                  "Exact time", "Test Name"
           FROM   gaze_data
           WHERE  "Test Name" = ?1"#,
    );

    if !participants.is_empty() {
        query.push_str(" AND \"Participant name\" IN (");
        query.push_str(&vec!["?"; participants.len()].join(","));
        query.push(')');
    }
    query.push_str(" ORDER BY \"Exact time\"");

    let mut stmt = conn.prepare(&query).map_err(|e| e.to_string())?;

    let mut params: Vec<&dyn rusqlite::ToSql> = vec![&test_name];
    for p in &participants {
        params.push(p);
    }

    let rows = stmt
        .query_map(rusqlite::params_from_iter(params), |row| {
            Ok(GazeData {
                gaze_x: row.get::<_, Option<f64>>(0)?,
                gaze_y: row.get::<_, Option<f64>>(1)?,
                box_name: row.get(2)?,
                media_name: row.get(3)?,
                timeline: row.get(4)?,
                participant: row.get(5)?,
                recording: row.get(6)?,
                timestamp: row.get(7)?,
                test_name: row.get(8)?,
            })
        })
        .map_err(|e| e.to_string())?;

    Ok(rows.collect::<SqlResult<Vec<GazeData>>>().map_err(|e| e.to_string())?)
}

#[tauri::command]
async fn get_box_stats(
    test_name: String,
    participants: Vec<String>,
    pool: State<'_, DbPool>,
) -> Result<GazeStats, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;

    let mut query = String::from(
        r#"SELECT Box, COUNT(*) AS count
           FROM   gaze_data
           WHERE  "Test Name" = ?1"#,
    );

    if !participants.is_empty() {
        query.push_str(" AND \"Participant name\" IN (");
        query.push_str(&vec!["?"; participants.len()].join(","));
        query.push(')');
    }
    query.push_str(" GROUP BY Box");

    let mut stmt = conn.prepare(&query).map_err(|e| e.to_string())?;

    let mut params: Vec<&dyn rusqlite::ToSql> = vec![&test_name];
    for p in &participants {
        params.push(p);
    }

    let mut box_counts = HashMap::new();
    let mut total_points = 0i64;

    let rows = stmt
        .query_map(rusqlite::params_from_iter(params), |row| {
            let box_name: String = row.get(0)?;
            let count: i64 = row.get(1)?;
            Ok((box_name, count))
        })
        .map_err(|e| e.to_string())?;

    for row in rows {
        let (box_name, count) = row.map_err(|e| e.to_string())?;
        total_points += count;
        box_counts.insert(box_name, count as f64);
    }
    for count in box_counts.values_mut() {
        *count = (*count / total_points as f64) * 100.0;
    }

    Ok(GazeStats { box_percentages: box_counts, total_points })
}

/* ──────────────────────────────────────────────────────────────
   test_catalog-backed features (replaces old word_windows/test_meta)
   ────────────────────────────────────────────────────────────── */

#[tauri::command]
async fn get_word_windows(
    test_name: String,
    pool: State<'_, DbPool>,
) -> Result<Vec<WordWindow>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;

    let mut stmt = conn.prepare(
        r#"SELECT timeline, word_windows_json, test_name
           FROM   test_catalog
           WHERE  test_name = ?1 OR ?1 LIKE test_name || '%'
           LIMIT  1"#,
    ).map_err(|e| e.to_string())?;

    let row_opt: Option<(Option<String>, Option<String>, String)> = stmt
        .query_row([&test_name], |row| {
            Ok((
                row.get::<_, Option<String>>(0)?,
                row.get::<_, Option<String>>(1)?,
                row.get::<_, String>(2)?,
            ))
        })
        .optional()
        .map_err(|e| e.to_string())?;

    if let Some((timeline_opt, json_opt, tname)) = row_opt {
        let timeline = timeline_opt.unwrap_or_default();
        let mut out = Vec::<WordWindow>::new();
        if let Some(json) = json_opt {
            let val: serde_json::Value = serde_json::from_str(&json).map_err(|e| e.to_string())?;
            if let Some(arr) = val.as_array() {
                for it in arr {
                    let w = it.get("w").and_then(|v| v.as_str()).unwrap_or("").to_string();
                    let start = it.get("start").and_then(|v| v.as_f64()).unwrap_or(0.0);
                    let end = it.get("end").and_then(|v| v.as_f64()).unwrap_or(0.0);
                    out.push(WordWindow {
                        chinese_word: w,
                        start_sec: start,
                        end_sec: end,
                        test_name: tname.clone(),
                        timeline: timeline.clone(),
                    });
                }
            }
        }
        Ok(out)
    } else {
        Ok(vec![])
    }
}

#[tauri::command]
async fn get_test_image(
    app: AppHandle,
    test_name: String,
    pool: State<'_, DbPool>,
) -> Result<Option<String>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    let mut stmt = conn.prepare(
        r#"SELECT image_path
           FROM   test_catalog
           WHERE  test_name = ?1 OR ?1 LIKE test_name || '%'
           LIMIT  1"#,
    ).map_err(|e| e.to_string())?;

    let image_path: Option<String> = stmt
        .query_row([&test_name], |row| row.get::<_, Option<String>>(0))
        .optional()
        .map_err(|e| e.to_string())?
        .flatten();

    let Some(rel) = image_path else { return Ok(None); };
    if rel.trim().is_empty() { return Ok(None); }

    // resources/test_images/*
    let base = app.path()
        .resolve("resources", BaseDirectory::Resource)
        .map_err(|e| e.to_string())?;
    let mut full: PathBuf = base;
    full.push(rel);

    let bytes = fs::read(&full).map_err(|e| format!("read image: {e}"))?;
    let b64 = general_purpose::STANDARD.encode(bytes);
    Ok(Some(b64))
}

/* AOI map remains optional; empty = fall back to defaults in UI */
#[tauri::command]
async fn get_aoi_map(
    test_name: String,
    pool: State<'_, DbPool>,
) -> Result<Vec<AoiRow>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    if !table_exists(&conn, "aoi_map") {
        return Ok(vec![]);
    }
    let mut stmt = conn.prepare(
        r#"SELECT tag, region_id, rgb_hex
           FROM   aoi_map
           WHERE  test_name = ?1"#,
    ).map_err(|e| e.to_string())?;

    let rows = stmt
        .query_map([&test_name], |row| {
            Ok(AoiRow {
                tag: row.get(0)?,
                region_id: row.get(1)?,
                rgb_hex: row.get::<_, Option<String>>(2)?,
            })
        })
        .map_err(|e| e.to_string())?;

    Ok(rows.collect::<SqlResult<Vec<AoiRow>>>().map_err(|e| e.to_string())?)
}

/* Back-compat: frontend still calls get_all_test_meta.
   We read from test_catalog and PARSE case_no from TEXT → Option<i64>. */
#[tauri::command]
async fn get_all_test_meta(pool: State<'_, DbPool>) -> Result<Vec<TestMetaRow>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    let mut stmt = conn.prepare(
        r#"SELECT test_name, sentence, truth_value, only_position,
                  morpheme, series, case_no
           FROM   test_catalog"#,
    ).map_err(|e| e.to_string())?;

    let rows = stmt.query_map([], |row| {
        let case_txt: Option<String> = row.get(6)?;
        let case_no = case_txt.and_then(|s| s.trim().parse::<i64>().ok());
        Ok(TestMetaRow {
            test_name: row.get(0)?,
            sentence: row.get(1)?,
            truth_value: row.get(2)?,
            only_position: row.get(3)?,
            morpheme: row.get(4)?,
            series: row.get(5)?,
            case_no,
        })
    }).map_err(|e| e.to_string())?;

    Ok(rows.collect::<SqlResult<Vec<TestMetaRow>>>().map_err(|e| e.to_string())?)
}

/* New: the full(er) catalog dump for tools / admin UI */
#[tauri::command]
async fn get_all_test_catelog(pool: State<'_, DbPool>) -> Result<Vec<TestCatalogRow>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    let mut stmt = conn.prepare(
        r#"SELECT
              test_name, sentence, "group", correct_AOIs, potentially_correct_AOIs,
              incorrect_AOIs, correct_NULL, potentially_correct_NULL, incorrect_NULL,
              truth_value, only_position, morpheme, series, case_no,
              "Image name", timeline, word_windows_json, missing, image_path
           FROM test_catalog
           ORDER BY test_name"#,
    ).map_err(|e| e.to_string())?;

    let rows = stmt.query_map([], |row| {
        let case_txt: Option<String> = row.get(13)?;
        let case_no = case_txt.and_then(|s| s.trim().parse::<i64>().ok());
        Ok(TestCatalogRow {
            test_name: row.get(0)?,
            sentence: row.get(1)?,
            group: row.get(2)?,
            correct_AOIs: row.get(3)?,
            potentially_correct_AOIs: row.get(4)?,
            incorrect_AOIs: row.get(5)?,
            correct_NULL: row.get(6)?,
            potentially_correct_NULL: row.get(7)?,
            incorrect_NULL: row.get(8)?,
            truth_value: row.get(9)?,
            only_position: row.get(10)?,
            morpheme: row.get(11)?,
            series: row.get(12)?,
            case_no,
            image_name: row.get(14)?,
            timeline: row.get(15)?,
            word_windows_json: row.get(16)?,
            missing: row.get(17)?,
            image_path: row.get(18)?,
        })
    }).map_err(|e| e.to_string())?;

    Ok(rows.collect::<SqlResult<Vec<TestCatalogRow>>>().map_err(|e| e.to_string())?)
}

/* Optional alias with the correct spelling, in case you want it later.
#[tauri::command]
async fn get_all_test_catalog(pool: State<'_, DbPool>) -> Result<Vec<TestCatalogRow>, String> {
    get_all_test_catelog(pool).await
}
*/

/* New: recordings table dump */
#[tauri::command]
async fn get_all_recordings(pool: State<'_, DbPool>) -> Result<Vec<RecordingRow>, String> {
    let conn = pool.0.get().map_err(|e| e.to_string())?;
    if !table_exists(&conn, "recordings") {
        return Ok(vec![]);
    }

    let mut stmt = conn.prepare(
        r#"SELECT "Recording", "Participant", "Timeline", "Duration", "Date", "Gaze samples"
           FROM   recordings
           ORDER  BY "Date", "Recording""#,
    ).map_err(|e| e.to_string())?;

    let rows = stmt.query_map([], |row| {
        Ok(RecordingRow {
            recording: row.get(0)?,
            participant: row.get(1)?,
            timeline: row.get(2)?,
            duration: row.get(3)?,
            date: row.get(4)?,
            gaze_samples: row.get::<_, Option<i64>>(5)?,
        })
    }).map_err(|e| e.to_string())?;

    Ok(rows.collect::<SqlResult<Vec<RecordingRow>>>().map_err(|e| e.to_string())?)
}

/* ──────────────────────────────────────────────────────────────
   App bootstrap
   ────────────────────────────────────────────────────────────── */

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            println!("Setting up the application...");

            let resource_path = app
                .path()
                .resolve("resources/eye_tracking.db", BaseDirectory::Resource)
                .map_err(|e| {
                    println!("Failed to resolve DB path: {e}");
                    e
                })?;

            if resource_path.exists() {
                println!("DB found at: {:?}", resource_path);
            } else {
                println!("DB MISSING at: {:?}", resource_path);
            }

            let manager = SqliteConnectionManager::file(&resource_path);
            let pool = Pool::new(manager).map_err(|e| {
                println!("Failed to create DB pool: {e}");
                e
            })?;

            app.manage(DbPool(Arc::new(pool)));
            println!("Setup completed.");
            Ok(())
        })
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_fs::init())
        .invoke_handler(tauri::generate_handler![
            // gaze
            get_participants,
            get_test_names,
            get_gaze_data,
            get_box_stats,
            // catalog / meta / images
            get_word_windows,
            get_test_image,
            get_aoi_map,
            get_all_test_meta,     // back-compat
            get_all_test_catelog,  // new
            // get_all_test_catalog, // optional alias (see above)
            // recordings
            get_all_recordings,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
